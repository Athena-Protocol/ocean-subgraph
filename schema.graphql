type OceanPools @entity {
    id: ID!
    color: String!                                      # Bronze, Silver, Gold
    poolCount: Int!                                     # Number of pools
    finalizedPoolCount: Int!                            # Number of finalized pools
    pools: [Pool!] @derivedFrom(field: "factoryID")
    txCount: BigInt!                                    # Number of txs
    totalLiquidity: BigDecimal!                         # All the pools liquidity value in Ocean
    totalSwapVolume: BigDecimal!                        # All the swap volume in Ocean
    totalSwapFee: BigDecimal!                           # All the swap fee in Ocean
}

type Pool @entity {
    id: ID!                                             # Pool address
    controller: Bytes!                                  # Controller address
    publicSwap: Boolean!                                # isPublicSwap
    finalized: Boolean!                                 # isFinalized
    symbol: String                                      # Pool token symbol
    name: String                                        # Pool token name
    cap: BigInt                                         # Maximum supply if any
    active: Boolean!                                    # isActive
    swapFee: BigDecimal!                                # Swap Fees
    totalWeight: BigDecimal!
    totalShares: BigDecimal!                            # Total pool token shares
    totalSwapVolume: BigDecimal!                        # Total swap volume in OCEAN
    totalSwapFee: BigDecimal!                           # Total swap fee in OCEAN
    liquidity: BigDecimal!                              # Pool liquidity value in OCEAN
    tokensList: [Bytes!]!                               # Temp workaround until graph supports filtering on derived field
    tokens: [PoolToken!] @derivedFrom(field: "poolId")
    shares: [PoolShare!] @derivedFrom(field: "poolId")
    createTime: Int!                                    # Block time pool was created
    tokensCount: BigInt!                                # Number of tokens in the pool
    holdersCount: BigInt!                               # Number of addresses holding a positive balance of BPT
    joinsCount: BigInt!                                 # liquidity has been added
    exitsCount: BigInt!                                 # liquidity has been removed
    swapsCount: BigInt!
    factoryID: OceanPools!
    tx: Bytes                                           # Pool creation transaction id
    swaps: [Swap!] @derivedFrom(field: "poolAddress")
}

type PoolToken @entity {
    id: ID!                                             # poolId + token address
    poolId: Pool!
    tokenId: Datatoken
    address: String
    balance: BigDecimal!
    denormWeight: BigDecimal!
}

type PoolShare @entity {
    id: ID!                                             # poolId + userAddress
    userAddress: User!
    poolId: Pool!
    balance: BigDecimal!
}

type User @entity {
    id: ID!
    sharesOwned: [PoolShare!]  @derivedFrom(field: "userAddress")
    tokenBalancesOwned: [TokenBalance!] @derivedFrom(field: "userAddress")
    tokensOwned: [Datatoken!] @derivedFrom(field: "minter")
    poolTxs: [PoolTransaction!]  @derivedFrom(field: "userAddress")
    tokenTxs: [TokenTransaction!]  @derivedFrom(field: "userAddress")
    swaps: [Swap!]  @derivedFrom(field: "userAddress")

}

type Swap @entity {
    id: ID!                                 #
    caller: Bytes!                          #
    tokenIn: Bytes!                         #
    tokenInSym: String!                     #
    tokenOut: Bytes!                        #
    tokenOutSym: String!                    #
    tokenAmountIn: BigDecimal!              #
    tokenAmountOut: BigDecimal!             #
    poolAddress: Pool
    userAddress: User                       # User address that initiates the swap
    value: BigDecimal!                      # Swap value in OCEAN
    feeValue: BigDecimal!                   # Swap fee value in OCEAN
    poolTotalSwapVolume: BigDecimal!        # Total pool swap volume in OCEAN
    poolTotalSwapFee: BigDecimal!           # Total pool swap fee in OCEAN
    poolLiquidity: BigDecimal!              # Pool liquidity value in OCEAN
    timestamp: Int!
}

type PoolTransaction @entity {
    id: ID!                         # Log ID
    tx: Bytes!
    event: String
    block: Int!
    timestamp: Int!
    gasUsed: BigDecimal!
    gasPrice: BigDecimal!
    poolAddress: Pool
    userAddress: User
    action: SwapType
    sender: Bytes
}

type TokenPrice @entity {
    id: ID!
    symbol: String
    name: String
    decimals: Int!
    price: BigDecimal!
    poolLiquidity: BigDecimal!
    poolTokenId: String
}

type OceanDatatokens @entity {
    id: ID!
    tokenCount: Int!                                     # Number of datatokens
    datatokens: [Datatoken!] @derivedFrom(field: "factoryID")
    txCount: BigInt!                                    # Number of txs
}

type Datatoken @entity {
    id: ID!                                             # token address
    factoryID: OceanDatatokens!
    symbol: String
    name: String
    decimals: Int!
    address: String!
    cap: BigDecimal!
    supply: BigDecimal!
    minter: User!
    publisher: User!
    balances: [TokenBalance!] @derivedFrom(field: "datatokenId")
    orders: [TokenOrder!] @derivedFrom(field: "datatokenId")
    createTime: Int!                                    # Block time datatoken was created
    holdersCount: BigInt!                               # Number of addresses holding a balance of datatoken
    orderCount: BigInt!                                 # Number of orders executed for this dataset
    tx: Bytes                                           # Datatoken creation transaction id
}

type TokenOrder @entity {
    id: ID!                                             # datatokenId + userAddress + tx
    datatokenId: Datatoken!
    consumer: User!
    payer: User!
    amount: BigDecimal!
    serviceId: Int!
    timestamp: Int!
    marketFeeCollector: User
    marketFee: BigDecimal!
    tx: Bytes
}

type TokenBalance @entity {
    id: ID!                                             # datatokenId + userAddress
    userAddress: User!
    datatokenId: Datatoken!
    balance: BigDecimal!
}

type TokenTransaction @entity {
    id: ID!                         # Log ID
    tx: Bytes!
    event: String
    block: Int!
    timestamp: Int!
    gasUsed: BigDecimal!
    gasPrice: BigDecimal!
    datatokenAddress: Datatoken
    userAddress: User
    sender: Bytes

}

enum SwapType {
    swapExactAmountIn,
    swapExactAmountOut,
    joinswapExternAmountIn,
    joinswapPoolAmountOut,
    exitswapPoolAmountIn,
    exitswapExternAmountOut
}