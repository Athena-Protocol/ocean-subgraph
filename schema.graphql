type Token @entity {

    id: ID!                                               
    symbol: String                                      
    name: String                                          
    decimals: Int!                                        
    address: String!                                      
    cap: BigDecimal                                       
    supply: BigDecimal                                    
    isDatatoken: Boolean!                                 
    
    "address of ERC721 that owns the token, valid only for datatokens"
    owner: String        
    "array of addresses with minter role, can be user wallet address, dispenser etc."                                 
    minter: [User!] 
    "TODO: maybe we change name , depends on audit results . It's the address that collects the payments (NOT fees)"                                      
    feeManager: String             
    "address of the market where the datatoken was created. This address collects market fees."                       
    publishMarketFeeAddress: String  
    "adreess of fee token (can be Ocean, ETH, etc.)"                     
    publishMarketFeeToken: String            
    "fee amount. Fixed value, expressed in wei in contracts, needs conversion in decimals."             
    publishMarketFeeAmmount: BigDecimal         
    "template ID of the datatoken"                               
    templateId: Int                                       

    "number of addresses holding a balance of datatoken , TODO: can we actually calculate this? what happens when users trade the dts"
    holderCount: BigInt   
    "number of orders executed for this datatoken"                                
    orderCount: BigInt                                    

    "block time datatoken was created"
    createdTimestamp: Int        
    "datatoken creation transaction id"                         
    tx: Bytes        
    "block number when it was created"                                   
    block: Int                                            
}

"utility type"
type TokenValuePair @entity {
   id : ID!
   token : Token!
   value : BigDecimal!
}

type Nft @entity{
    "nft address"
    id: ID!                                                
    symbol: String!                                       
    name: String!                                          
    tokenUri: String! 
    "address of the owner of the nft"                                     
    owner: String!     
    "same as id, it's just for easy discoverability"                                    
    address: String!     
    "provider url that can decrypt the ddo"                                  
    providerUrl: String  
    "state of the asset (described in docs)"                                  
    assetState: Int!                                       

    managerRole: [String!]
    erc20DeployerRole: [String!]
    storeUpdateRole: [String!] 
    "addresses that can update the metadata"
    metadataRole: [String!]                                 

    "template address"
    template: String!           


    "block time nft was created"
    createdTimestamp: Int!                                  
    "nft creation transaction id"
    tx: Bytes   
    "block number when it was created"                                            
    block: Int                                              
}

type Pool @entity {
    "pool address"
    id: ID!              
    "owner address, pool controller"                                   
    owner: String! 
    "if swap/trade is activated, probably always true"                                         
    isPublicSwap: Boolean!     
    "only finalized pools are relevant to us"                             
    isFinalized: Boolean!                                   
    
    "pool token symbol"
    symbol: String      
    "pool token name"                                    
    name: String    
    "maximum supply if any, converted from wei"                                        
    cap: BigDecimal            
    "pool is active"                            
    isActive: Boolean!                                      

    baseToken: PoolToken! 
    datatoken: PoolToken!
    "pool Fee percent, fee goes to all liquidity providers : SWAP, JOIN , EXIT"
    poolFee: BigDecimal! 
    "OPF Fee percent, fee that goes to Ocean Protocol Foundation : SWAP"                                    
    opfFee: BigDecimal!   
    "market fee percent, fee that goes to the market where the pool was created : SWAP"                                  
    marketFee: BigDecimal!     
    "actual value of fee collected in both tokens"                             
    totalPoolFee: [TokenValuePair!]!  
    "actual value of fee collected in both tokens"                          
    totalOpfFee: [TokenValuePair!]!   
    "actual value of fee collected in both tokens"                          
    totalMarketFee: [TokenValuePair!]!                            

    "fee after collection =  totalFee - colectedFee"
    currentOpfFee: [TokenValuePair!]!     
    "fee after collection totalFee - colectedFee"                      
    currentMarketFee: [TokenValuePair!]!                        

    "it's always 100 TODO: should be removed, seems redundant"
    totalWeight: BigDecimal!     
    "total pool token shares"                           
    totalShares: BigDecimal!   
    "total tokens that were swaped"                             
    totalSwapVolume: [TokenValuePair!]!                         

    spotPrice: BigDecimal!                                  

    "count for when liquidity has been added"
    joinCount: BigInt!                 
    "count for when liquidity has been removed"                     
    exitCount: BigInt!                                      
    swapCount: BigInt!
    "number of transactions in this pool involving liquidity changes"
    transactionCount: BigInt!                               
   
    "block time when pool was created"
    createdTimestamp: Int!      
    "pool creation transaction id"                            
    tx: Bytes    
    "block number when it was created"                                          
    block: Int                                              

    shares: [PoolShare!] @derivedFrom(field: "pool")
    transactions: [PoolTransaction!] @derivedFrom(field: "pool")
}

# should not pe @entity
type PoolToken @entity {
    "pool address + token address"
    id: ID!                                                
    pool: Pool!                                             
    token: Token!
    "balance of the token in this pool"
    balance: BigDecimal!         
    "weight of token in the pool (50% for ocean bpools)"                            
    denormWeight: BigDecimal!                              
}

# we will need to track pool share tx between users -  bpool transfer tx event
type PoolShare @entity {
  "poolAddress + userAddress"
  id: ID!                                                   
  user: User!
  pool: Pool!
  balance: BigDecimal!
}

 enum PoolTransactionType {
  JOIN,
  EXIT,
  SWAP,
  SETUP
}

type PoolTransaction @entity {
  "tx address + caller address" 
  id: ID!        
  "pool related to this tx"                                            
  pool: Pool!   
  "user that initiates the tx"                                             
  user: User!                                              
  type: PoolTransactionType                                                  
  
  "number of shares transfered"
  sharesTransferAmount: BigDecimal                           
 
  "pool fee percent, fee goes to all liquidity providers : SWAP, JOIN , EXIT"
  poolFee: BigDecimal!     
  "OPF Fee percent, fee that goes to Ocean Protocol Foundation : SWAP"                                  
  opfFee: BigDecimal!                                        
  marketFee: BigDecimal!  
  
  event: String                                              # TODO: what is this?

  tx: Bytes!
  block: Int!
  timestamp: Int!

  gasLimit: BigDecimal!  
  "price expressed in eth"                                    
  gasPrice: BigDecimal!                                      

  # change to baseToken and dataToken
  "base tokens transfered , if value is negative it means it was removed"
  baseToken: TokenValuePair        
  "datatokens transfered , if value is negative it means it was removed"                        
  datatoken: TokenValuePair
}

type Order @entity {                                         # renamed from TokenOrder to Order
  id: ID!                                                    # datatokenId + userAddress + tx
  token: Token!

  consumer: User!
  payer: User!
  amount: BigDecimal!
  serviceId: Int!


  # the fees will be updated from an event that will be created after (todo)
  publishingMarketAddress: User
  publishingMarketToken: Token                                #
  publishingMarketAmmount: BigDecimal                         #call contract to get fee ammount

  consumerMarketAddress: User
  consumerMarketToken: Token                                  #
  consumerMarketAmmount: BigDecimal                           #call contract to get fee ammount

  createdTimestamp: Int!
  tx: Bytes
  block: Int!
}

# to be removed, mabye for pool shares only 
type TokenTransaction @entity {
  id: ID! # Log ID
  event: String
  token: Token
  user: User

  block: Int!
  gasUsed: BigDecimal!
  gasPrice: BigDecimal!
  createdTimestamp: Int!
  tx: Bytes!
}

type User @entity {
  id: ID!
  sharesOwned: [PoolShare!] @derivedFrom(field: "user")
  tokenBalancesOwned: [TokenValuePair!]
  tokensOwned: [Token!] @derivedFrom(field: "minter")
  poolTransactions: [PoolTransaction!] @derivedFrom(field: "user")
  orders: [Order!] @derivedFrom(field: "payer")
  freSwaps: [FixedRateExchangeSwap!] @derivedFrom(field: "by")
}

type FixedRateExchange @entity {
  "fixed rate exchange id"
  id: ID!                                                    
  owner: User!
  datatoken: Token!
  baseToken: Token!
  price: BigDecimal!
  active: Boolean!
  "amount of total basetokens spent"
  totalSwapValue: BigDecimal!  
  "address that is allowed to  swap tokens"                              
  allowedSwapper: String                                     
  supply: BigInt!
  "if the owner allowes the fre to mint"
  withMint: Boolean  
  "if the fre has the minter role on the datatoken"                                        
  isMinter: Boolean                                          

  updates: [FixedRateExchangeUpdate!] @derivedFrom(field: "exchangeId")
  swaps: [FixedRateExchangeSwap!] @derivedFrom(field: "exchangeId")

  createdTimestamp: Int!
  tx: Bytes
  block: Int!
}

type FixedRateExchangeUpdate @entity {
  id: ID!
  exchangeId: FixedRateExchange!

  oldPrice: BigDecimal
  newPrice: BigDecimal

  oldActive: Boolean
  newActive: Boolean

  oldAllowedSwapper: String
  newAllowedSwapper: String

  block: Int!
  createdTimestamp: Int!
  tx: Bytes!
}

type FixedRateExchangeSwap @entity {
  id: ID!
  exchangeId: FixedRateExchange!
  by: User!
  baseTokenAmount: BigDecimal!
  dataTokenAmount: BigDecimal!
  block: Int!
  createdTimestamp: Int!
  tx: Bytes!
}


type Dispenser @entity {
  "datatoken address"
  id: ID!                                                      
  active: Boolean!                            
  owner: User!
  datatoken: Token!

  allowedSwapper: String
  isMinter: Boolean   
  "max tokens that can be dispensed"                                         
  maxTokens: BigDecimal! 
  "max balance of requester. If the balance is higher, the dispense is rejected"                              
  maxBalance: BigDecimal!    
  "how many tokens are left"                                   
  balance: BigDecimal!                                         
  
  dispenses: [DispenserTransaction!] @derivedFrom(field: "dispenser")
}

type DispenserTransaction @entity {
  id: ID!                                                      
  dispenser: Dispenser!
  user: User!
  amount: BigDecimal!

  block: Int!
  createdTimestamp: Int!
  tx: Bytes!
}

type PoolSnapshot @entity {
  id: ID!
  pool: Pool!
  totalShares: BigDecimal!
  "swap value 24h"
  swapVolume: BigDecimal!   
  "swap fee value 24h"                                          
  swapFees: BigDecimal! 
  "date without time"                                              
  createdTimestamp: Int!                                          
  spotPrice: BigDecimal!                                              # TODO: last spot price or first one?
  tokens: [PoolSnapshotTokenValue!] @derivedFrom(field: "poolSnapshot")
}

type PoolSnapshotTokenValue @entity {
  id: ID!                                                            # pool tx +  tokenAddress
  token: Token!
  value: BigDecimal!                                            
  tokenReserve: BigDecimal!                                          # how many tokens are left in pool
  poolSnapshot: PoolSnapshot! 
}

type Global @entity {
    id: ID!

    "total value locked represented in the base token , basically 2x liqudity for each base token"
    totalValueLocked: [TokenValuePair!]    
    "total liquidity for each base token"                  
    totalLiquidity: [TokenValuePair!]                        
    "total swap volume for each base token. pools and fre"
    totalSwapVolume: [TokenValuePair!]                                
     
    "number of total consumes, pools + fre"
    orderCount: BigInt                                     

    "number of pools for all factories"
    poolCount: Int!       
    "number of finalized pools for all factories"                                  
    finalizedPoolCount: Int!                   
    "probably remove due to inconsistencies and imposibility to calculate"             
    totalOrderVolume: BigDecimal                            
}


type MetadataUpdate @entity {
  id: ID! # update tx +  datatokenAddress
  datatoken: Token!

  datatokenAddress: String!
  userAddress: String!

  block: Int!
  createdTimestamp: Int!
  tx: Bytes!
}
