type PoolFactory @entity {
    id: ID!
    totalValueLocked: [TokenValuePair]                    # total value locked represented in the base token                           
    totalLiquidity: [TokenValuePair]                      # total liquidity for each base token 
    totalSwapVolume: [TokenValuePair]                     # total swap volume for each base token
    totalSwapFee: [TokenValuePair]                        # All the swap fee in Ocean

    poolCount: Int!                                       # Number of pools
    finalizedPoolCount: Int!                              # Number of finalized pools
    orderCount: BigInt                                    # Number of total consumes
    totalOrderVolume: BigDecimal                          # probably remove due to inconsistencies and imposibility to calculate
   
    pools: [Pool!] @derivedFrom(field: "factoryID")
}


type Global @entity {
    id: ID!

    totalValueLocked: [TokenValuePair]                    # total value locked represented in the base token 
    totalLiquidity: [TokenValuePair]                      # total liquidity for each base token 
    totalSwapVolume: [TokenValuePair]                     # total swap volume for each base token. pools and fre             
    
    totalOrderVolume: BigDecimal
     
    orderCount: BigInt                                    # Number of total consumes, pools + fre

    poolCount: Int!                                       # Number of pools for all factories
    finalizedPoolCount: Int!                              # Number of finalized pools for all factories
}


type TokenValuePair @entity {

   token : Token!
   value : BigDecimal!

}


type Token @entity {
    id: ID!                                               # 
    symbol: String                                        #
    name: String                                          #
    decimals: Int!                                        #
    address: String!                                      #
    cap: BigDecimal!                                      #
    supply: BigDecimal!                                   #
    isDatatoken: Boolean!                                 #

    factory: DatatokenFactory                             #

    creator: String                                       # TODO:
    publisher: String                                     # TODO:
    minter: String                                        # TODO:
    editor: String                                        # TODO:

    holderCount: BigInt                                   # Number of addresses holding a balance of datatoken
    orderCount: BigInt                                    # Number of orders executed for this datatoken

    createTime: Int                                       # Block time datatoken was created
    tx: Bytes                                             # Datatoken creation transaction id
    block: Int                                            # Block number when it was created
}



type Pool @entity {
    id: ID!                                             # Pool address
    poolFactory: PoolFactory!                           # Pool factory
    controller: Bytes!                                  # Controller address
    isPublicSwap: Boolean!                              # TODO : what is this?
    isFinalized: Boolean!                               # only finalized pools are relevant to us
    
    symbol: String                                      # Pool token symbol
    name: String                                        # Pool token name
    cap: BigInt                                         # Maximum supply if any
    isActive: Boolean!                                  # 
    swapFee: BigDecimal!                                # Swap Fees

    totalWeight: BigDecimal!                            # TODO: What is this?
    totalShares: BigDecimal!                            # Total pool token shares
    totalSwapVolume: BigDecimal!                        # Total swap volume in main token
    totalSwapFee: BigDecimal!                           # TODO: is this correct ? Total swap fee in main token 

    totalValueLocked: BigDecimal!                            # value locked in pool expressed in main token (captures both Ocean and Datatoken)

    spotPrice: BigDecimal!
    consumePrice: BigDecimal!                           # TODO: still need?

    // what is the point of the counts, we never used them => remove
    joinCount: BigInt!                                 # liquidity has been added
    exitCount: BigInt!                                 # liquidity has been removed
    swapCount: BigInt!
    transactionCount: BigInt!                          # Number of transactions in this pool involving liquidity changes
    
    // remove
    datatokenAddress: String!
   
    createTime: Int!                                    # Block time pool was created
    tx: Bytes                                           # Pool creation transaction id
    block

    tokens: [PoolToken!] @derivedFrom(field: "poolId")
    shares: [PoolShare!] @derivedFrom(field: "poolId")
    transactions: [PoolTransaction!] @derivedFrom(field: "poolAddress")
    //this doesn't make sens, probably here because we had to link to pool
    transactionsTokenValues: [PoolTransactionTokenValues!] @derivedFrom(field: "poolAddress")
}

//PoolToken - all good as it is

type PoolToken @entity {
    id: ID!                                             # poolId + token address
    pool: Pool!                                         # 
    isDatatoken: Boolean!                               # if the token is a datatoken , not sure if this makes sense since it is duplicate information found on token
    token: Token!
    balance: BigDecimal!                                # balance of the token in this pool
    denormWeight: BigDecimal!                       
    symbol: String                                      # should we keep this, it is found on token?
    name: String                                        # should we keep this, it is found on token?
    decimals: Int                                       # should we keep this, it is found on token?
}


type PoolShare @entity {
  id: ID!                                                 # poolId + userAddress
  user: User!
  pool: Pool!
  balance: BigDecimal!
}

// Will be replaced with a generic PoolTokenValue WIP

type PoolTransactionTokenValues @entity {
  id: ID! # pool tx +  tokenAddress
  txId: PoolTransaction!

  // should be an array of PoolToken
  poolToken: PoolToken!
  // not sure if needed
  poolAddress: Pool!
  //not sure if needed
  userAddress: User!

  // we will have the poolToken array, what will this be?
  tokenAddress: String!

  // value of what?
  value: BigDecimal!

  // should be an array if we keep this
  tokenReserve: BigDecimal!
  feeValue: BigDecimal! # Swap fee value in OCEAN
  type: String!
}

type PoolTransaction @entity {
  id: ID! # pool tx
  poolAddress --> pool: Pool
  userAddress --> user: User                                                         # User address that initiates the swap
  poolAddressStr --> poolAddress: String!
  userAddressStr --> userAddress: String!

  sharesTransferAmount: BigDecimal! #
  sharesBalance: BigDecimal!

  spotPrice: BigDecimal!
  // should not be here
  consumePrice: BigDecimal!
  tx: Bytes!
  event: String
  block: Int!
  timestamp: Int!
  gasUsed: BigDecimal!
  gasPrice: BigDecimal!

// should be an array, we will not have only ocean, it will be the tokens array
  oceanReserve: BigDecimal!
  datatokenReserve: BigDecimal!

  tokens: [PoolTransactionTokenValues!] @derivedFrom(field: "txId")
}


// we will have 2 dt factories ?
type DatatokenFactory @entity {
  id: ID!

  tokenCount: Int! # Number of datatokens
  datatokens: [Datatoken!] @derivedFrom(field: "factoryID")
}


type MetadataUpdate @entity {
  id: ID! # update tx +  datatokenAddress
  datatokenId: Datatoken!

  datatokenAddress: String!
  userAddress: String!

//all fields from the market edit
name 
description
author
links
timeout


  block: Int!
  timestamp: Int!
  tx: Bytes!
}

type Asset {

did
name 
description
author
services ? [ access, compute ] ?

datatoken : Datatoken
}



type TokenOrder @entity {
  id: ID! # datatokenId + userAddress + tx
  datatokenId: Datatoken!

  consumer: User!
  payer: User!
  amount: BigDecimal!
  serviceId: Int!
  marketFeeCollector: User
  marketFee: BigDecimal!

  timestamp: Int!
  tx: Bytes
  block: Int!
}

type TokenBalance @entity {
  id: ID! # datatokenId + userAddress
  userAddress: User!
  datatokenId: Datatoken!
  balance: BigDecimal!
}

type TokenTransaction @entity {
  id: ID! # Log ID
  event: String
  datatokenAddress: Datatoken
  userAddress: User

  block: Int!
  gasUsed: BigDecimal!
  gasPrice: BigDecimal!
  timestamp: Int!
  tx: Bytes!
}

type User @entity {
  id: ID!

  sharesOwned: [PoolShare!] @derivedFrom(field: "userAddress")
  tokenBalancesOwned: [TokenBalance!] @derivedFrom(field: "userAddress")
  tokensOwned: [Datatoken!] @derivedFrom(field: "minter")
  poolTransactions: [PoolTransaction!] @derivedFrom(field: "userAddress")
  poolTransactionsTokenValues: [PoolTransactionTokenValues!]
    @derivedFrom(field: "userAddress")
  tokenTransactions: [TokenTransaction!] @derivedFrom(field: "userAddress")
  orders: [TokenOrder!] @derivedFrom(field: "payer")
  freSwaps: [FixedRateExchangeSwap!] @derivedFrom(field: "by")
}

type FixedRateExchange @entity {
  id: ID! # fixed rate exchange id
  exchangeOwner: User!
  datatoken: Datatoken!
  // will be a token not just an address
  baseToken: String!
  // no need for this, since it will be on token
  baseTokenSymbol: String!
  rate: BigDecimal!
  active: Boolean!
  updates: [FixedRateExchangeUpdate!] @derivedFrom(field: "exchangeId")
  swaps: [FixedRateExchangeSwap!] @derivedFrom(field: "exchangeId")
}

type FixedRateExchangeUpdate @entity {
  id: ID!
  exchangeId: FixedRateExchange!
  oldRate: BigDecimal!
  newRate: BigDecimal!
  oldActive: Boolean!
  newActive: Boolean!
  block: Int!
  timestamp: Int!
  tx: Bytes!
}

type FixedRateExchangeSwap @entity {
  id: ID!
  exchangeId: FixedRateExchange!
  by: User!
  baseTokenAmount: BigDecimal!
  dataTokenAmount: BigDecimal!
  block: Int!
  timestamp: Int!
  tx: Bytes!
}

type Dispenser @entity {
  id: ID! # dispenser datatoken
  active: Boolean!
  owner: User!
  minterApproved: Boolean!
  isTrueMinter: Boolean!
  maxTokens: BigDecimal!
  maxBalance: BigDecimal!
  balance: BigDecimal!
  datatoken: Datatoken!
  dispenses: [DispenserTransaction!] @derivedFrom(field: "dispenserId")
}

type DispenserTransaction @entity {
  id: ID!
  dispenserId: Dispenser!
  datatoken: Datatoken!
  user: User!
  amount: BigDecimal!
  block: Int!
  timestamp: Int!
  tx: Bytes!
  type: String!
}


type PoolSnapshotTokenValue @entity {
  id: ID! # pool tx +  tokenAddress
  tokenAddress: String!
  value: BigDecimal!
  tokenReserve: BigDecimal!
  feeValue: BigDecimal! # Swap fee value in OCEAN
  type: String!
  poolSnapshot: PoolSnapshot! 
}


type PoolSnapshot @entity {
  id: ID!
  pool: Pool!
  totalShares: BigDecimal!
  swapVolume: BigDecimal!
  swapFees: BigDecimal!
  timestamp: Int!
  tokens: [PoolSnapshotTokenValue!] @derivedFrom(field: "poolSnapshot")
}

