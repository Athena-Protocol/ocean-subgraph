type Token @entity {
    id: ID!                                               # 
    symbol: String                                        #
    name: String                                          #
    decimals: Int!                                        #
    address: String!                                      #
    cap: BigDecimal                                       #
    supply: BigDecimal                                    #
    isDatatoken: Boolean!                                 #
    
    owner: String                                         # address of ERC721 that owns the token, valid only for datatokens
    minter: [User!]                                       # array of addresses with minter role, can be user wallet address, dispenser etc.
    feeManager: String                                    # TODO: maybe we change name , depends on audit results . It's the address that collects the payments (NOT fees)
    publishMarketFeeAddress: String                       # address of the market where the datatoken was created. This address collects market fees.
    publishMarketFeeToken: String                         # adreess of fee token (can be Ocean, ETH, etc.)
    publishMarketFeeAmmount: BigDecimal                   # fee amount. Fixed value, expressed in wei in contracts, needs conversion in decimals.                     
    templateId: Int                                       # template ID of the datatoken
    
    holderCount: BigInt                                   # Number of addresses holding a balance of datatoken , TODO: can we actually calculate this? what happens when users trade the dts
    orderCount: BigInt                                    # Number of orders executed for this datatoken

    createdTimestamp: Int                                       # Block time datatoken was created
    tx: Bytes                                             # Datatoken creation transaction id
    block: Int                                            # Block number when it was created
}

type TokenValuePair @entity {
   id : ID!
   token : Token!
   value : BigDecimal!
}

type Nft @entity{
    id: ID!                                                # nft address
    symbol: String!                                        #
    name: String!                                          #
    tokenUri: String!                                      #
    owner: String!                                         # owner of the nft
    address: String!                                       #
    providerUrl: String                                    # provider url that can decrypt the ddo 
    assetState: Int!                                       # state of the asset (described in docs)

    managerRole: [String!]
    erc20DeployerRole: [String!]
    storeUpdateRole: [String!] 
    metadataRole: [String!]                                  # addresses that can update the metadata

    template: String!                                       # template address
    createdTimestamp: Int!                                        # Block time pool was created
    tx: Bytes                                               # Pool creation transaction id
    block: Int                                              # Block number when it was created
}

type Pool @entity {
    id: ID!                                                 # Pool address
    owner: String!                                          # Owner address, pool controller

    isPublicSwap: Boolean!                                  # if swap/trade is activated, probably always true
    isFinalized: Boolean!                                   # only finalized pools are relevant to us
    
    symbol: String                                          # Pool token symbol
    name: String                                            # Pool token name
    cap: BigDecimal                                         # Maximum supply if any, converted from wei
    isActive: Boolean!                                      # pool is active

    baseToken: PoolToken! @derivedFrom(field: "pool")
    datatoken: PoolToken! @derivedFrom(field: "pool")
    poolFee: BigDecimal!                                    # Pool Fee percent, fee goes to all liquidity providers : SWAP, JOIN , EXIT
    opfFee: BigDecimal!                                     # OPF Fee percent, fee that goes to Ocean Protocol Foundation : SWAP
    marketFee: BigDecimal!                                  # Market fee percent, fee that goes to the market where the pool was created : SWAP
    totalPoolFee: [TokenValuePair!]!                            # actual value of fee collected in both tokens
    totalOpfFee: [TokenValuePair!]!                             # actual value of fee collected in both tokens
    totalMarketFee: [TokenValuePair!]!                          # actual value of fee collected in both tokens  

    currentOpfFee: [TokenValuePair!]!                           # fee after collection totalFee - colectedFee
    currentMarketFee: [TokenValuePair!]!                        # fee after collection totalFee - colectedFee  

    totalWeight: BigDecimal!                                # it's always 100 
    totalShares: BigDecimal!                                # Total pool token shares
    totalSwapVolume: [TokenValuePair!]!                         # total tokens that were swaped

    spotPrice: BigDecimal!                                  # spot price

    joinCount: BigInt!                                      # liquidity has been added
    exitCount: BigInt!                                      # liquidity has been removed
    swapCount: BigInt!
    transactionCount: BigInt!                               # Number of transactions in this pool involving liquidity changes
   
    createdTimestamp: Int!                                        # Block time pool was created
    tx: Bytes                                               # Pool creation transaction id
    block: Int                                              # Block number when it was created

    shares: [PoolShare!] @derivedFrom(field: "pool")
    transactions: [PoolTransaction!] @derivedFrom(field: "pool")
}

# should not pe @entity
type PoolToken @entity {
    id: ID!                                                 # poolId + token address
    pool: Pool!                                             # 
    token: Token!
    balance: BigDecimal!                                    # balance of the token in this pool
    denormWeight: BigDecimal!                               # weight of token in the pool (50% for our pools)
}

# we will need to track pool share tx between users -  bpool transfer tx event
type PoolShare @entity {
  id: ID!                                                   # poolId + userAddress
  user: User!
  pool: Pool!
  balance: BigDecimal!
}


type PoolTransaction @entity {
  id: ID!                                                    # tx + caller
  pool: Pool!                                                # Pool related to this tx
  user: User!                                                # User that initiates the tx
  type: Int                                                  # 0 - JOIN, 1 - EXIT , 2 - SWAP, maybe change to enum
  
  sharesTransferAmount: BigDecimal                           # Number of shares transfered
 
  poolFee: BigDecimal!                                       # Pool Fee percent, fee goes to all liquidity providers : SWAP, JOIN , EXIT
  opfFee: BigDecimal!                                        # OPF Fee percent, fee that goes to Ocean Protocol Foundation : SWAP
  marketFee: BigDecimal!  
  
  event: String                                              # TODO: what is this?

  tx: Bytes!
  block: Int!
  timestamp: Int!

  gasLimit: BigDecimal!                                      
  gasPrice: BigDecimal!                                      # in eth

  # change to baseToken and dataToken
  baseToken: TokenValuePair                               # tokens transfered , if value is negative it means it was removed, 
  datatoken: TokenValuePair
}

type Order @entity {                                         # renamed from TokenOrder to Order
  id: ID!                                                    # datatokenId + userAddress + tx
  token: Token!

  consumer: User!
  payer: User!
  amount: BigDecimal!
  serviceId: Int!


  # the fees will be updated from an event that will be created after (todo)
  publishingMarketAddress: User
  publishingMarketToken: Token                                #
  publishingMarketAmmount: BigDecimal                         #call contract to get fee ammount

  consumerMarketAddress: User
  consumerMarketToken: Token                                  #
  consumerMarketAmmount: BigDecimal                           #call contract to get fee ammount

  createdTimestamp: Int!
  tx: Bytes
  block: Int!
}

# to be removed, mabye for pool shares only 
type TokenTransaction @entity {
  id: ID! # Log ID
  event: String
  token: Token
  user: User

  block: Int!
  gasUsed: BigDecimal!
  gasPrice: BigDecimal!
  createdTimestamp: Int!
  tx: Bytes!
}

type User @entity {
  id: ID!
  sharesOwned: [PoolShare!] @derivedFrom(field: "user")
  tokenBalancesOwned: [TokenValuePair!]
  tokensOwned: [Token!] @derivedFrom(field: "minter")
  poolTransactions: [PoolTransaction!] @derivedFrom(field: "user")
  orders: [Order!] @derivedFrom(field: "payer")
  freSwaps: [FixedRateExchangeSwap!] @derivedFrom(field: "by")
}

type FixedRateExchange @entity {
  id: ID!                                                    # fixed rate exchange id
  owner: User!
  datatoken: Token!
  baseToken: Token!
  price: BigDecimal!
  active: Boolean!
  totalSwapValue: BigDecimal!                                # amount of total basetokens spent
  allowedSwapper: String                                     # address that is allowed to  swap tokens
  supply: BigInt!
  withMint: Boolean                                          # if the owner allowes the fre to mint
  isMinter: Boolean                                          # if the fre has the minter role on the datatoken 

  updates: [FixedRateExchangeUpdate!] @derivedFrom(field: "exchangeId")
  swaps: [FixedRateExchangeSwap!] @derivedFrom(field: "exchangeId")

  createdTimestamp: Int!
  tx: Bytes
  block: Int!
}

type FixedRateExchangeUpdate @entity {
  id: ID!
  exchangeId: FixedRateExchange!

  oldPrice: BigDecimal
  newPrice: BigDecimal

  oldActive: Boolean
  newActive: Boolean

  oldAllowedSwapper: String
  newAllowedSwapper: String

  block: Int!
  createdTimestamp: Int!
  tx: Bytes!
}

type FixedRateExchangeSwap @entity {
  id: ID!
  exchangeId: FixedRateExchange!
  by: User!
  baseTokenAmount: BigDecimal!
  dataTokenAmount: BigDecimal!
  block: Int!
  createdTimestamp: Int!
  tx: Bytes!
}

# since in the template that we will use minterApproved is sort of "bundled" with isTrueMinter i think we should have only one field here to easily check if dispenser cand mint

type Dispenser @entity {
  id: ID!                                                      # it's the datatoken address
  active: Boolean!                            
  owner: User!
  datatoken: Token!

  allowedSwapper: String
  isMinter: Boolean                                            # if the fre has the minter role on the datatoken 
  maxTokens: BigDecimal!                                       # max tokens that can be dispensed
  maxBalance: BigDecimal!                                      # max balance of requester. If the balance is higher, the dispense is rejected
  balance: BigDecimal!                                         # how many tokens are left
  
  dispenses: [DispenserTransaction!] @derivedFrom(field: "dispenser")
}

type DispenserTransaction @entity {
  id: ID!                                                      
  dispenser: Dispenser!
  user: User!
  amount: BigDecimal!

  block: Int!
  createdTimestamp: Int!
  tx: Bytes!
}

type PoolSnapshot @entity {
  id: ID!
  pool: Pool!
  totalShares: BigDecimal!
  swapVolume: BigDecimal!                                             # swap value 24h
  swapFees: BigDecimal!                                               # swap fee value 24h  
  createdTimestamp: Int!                                                     # date without time
  spotPrice: BigDecimal!                                              # TODO: last spot price or first one?
  tokens: [PoolSnapshotTokenValue!] @derivedFrom(field: "poolSnapshot")
}

type PoolSnapshotTokenValue @entity {
  id: ID!                                                            # pool tx +  tokenAddress
  token: Token!
  value: BigDecimal!                                            
  tokenReserve: BigDecimal!                                          # how many tokens are left in pool
  poolSnapshot: PoolSnapshot! 
}

type Global @entity {
    id: ID!

    totalValueLocked: [TokenValuePair!]                      # total value locked represented in the base token , basically 2x liqudity for each base token
    totalLiquidity: [TokenValuePair!]                        # total liquidity for each base token 
    totalSwapVolume: [TokenValuePair!]                       # total swap volume for each base token. pools and fre             
     
    orderCount: BigInt                                      # Number of total consumes, pools + fre

    poolCount: Int!                                         # Number of pools for all factories
    finalizedPoolCount: Int!                                # Number of finalized pools for all factories
    totalOrderVolume: BigDecimal                            # probably remove due to inconsistencies and imposibility to calculate
}


type MetadataUpdate @entity {
  id: ID! # update tx +  datatokenAddress
  datatoken: Token!

  datatokenAddress: String!
  userAddress: String!

  block: Int!
  createdTimestamp: Int!
  tx: Bytes!
}
